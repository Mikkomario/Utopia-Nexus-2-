package nexus_test;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import flow_structure.TreeNode;
import nexus_http.ContentType;
import nexus_http.Headers;
import nexus_http.Headers.AcceptHeader;
import nexus_http.HttpStatus.StatusCategory;
import nexus_http.Method;
import nexus_http.Parameters;
import nexus_http.Path;
import nexus_http.Request;
import nexus_http.Response;
import nexus_rest.ResourceWriter.LinkWriteStyle;
import nexus_rest.RestRequestHandler;
import nexus_rest.SimpleResource;
import nexus_rest.XmlJsonWriterProvider;

/**
 * This test tests the restRequest handler and resource writing, using the simpleResource 
 * class as a model.
 * @author Mikko Hilpinen
 * @since 24.10.2015
 */
public class SimpleRestTest
{
	// ATTRIBUTES	---------------------
	
	private RestRequestHandler handler;
	
	
	// CONSTRUCTOR	---------------------
	
	/**
	 * Creates a new test setting
	 */
	public SimpleRestTest()
	{
		this.handler = new RestRequestHandler(new XmlJsonWriterProvider());
		this.handler.addRootResource(new SimpleResource(new Path("root", null, false), 
				Method.GET, Method.POST, Method.PUT));
	}

	
	// MAIN METHOD	---------------------
	
	/**
	 * Tests the basic rest logic
	 * @param args Not used
	 */
	public static void main(String[] args)
	{
		SimpleRestTest test = new SimpleRestTest();
		ClientResource root = test.createRootResource();
		
		root.put("testStarted", LocalDateTime.now().toString());
		
		// Adds some nodes
		Random random = new Random();
		test.createNResourcesUnder(root, random, 1);
		
		// Gets some nodes
		root.get(false);
		root.get(true);
	}
	
	
	// ACCESSORS	---------------------
	
	/**
	 * @return The request handler used in this test
	 */
	public RestRequestHandler getHandler()
	{
		return this.handler;
	}
	
	
	// OTHER METHODS	-----------------
	
	/**
	 * Takes a request, prints it, gets the response and prints it as well
	 * @param request The request that should be handled next
	 * @return The response generated by the handler
	 */
	public Response handleRequest(Request request)
	{
		System.out.println("-------------------");
		System.out.println("Request:");
		System.out.println(request);
		
		Response response = this.handler.handle(request);
		/*
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		try
		{
			out.write("ASD".getBytes());
		} catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		response.setBody(out);
		*/
		System.out.println("Response:");
		System.out.println(response);
		
		response.closeBody();
		return response;
	}
	
	private ClientResource createRootResource()
	{
		return new ClientResource();
	}
	
	private ClientResource createResource(ClientResource parent, Random random, int depth, 
			int width)
	{
		Map<String, String> content = new HashMap<>();
		content.put("property1", random.nextInt(100) + "");
		content.put("property2", random.nextInt(100) + "");
		content.put("property3", random.nextInt(100) + "");
		
		return new ClientResource("R" + depth + "." + width, content, parent);
	}
	
	private void createNResourcesUnder(ClientResource parent, Random random, int depth)
	{
		int max = random.nextInt(1 + 6 / depth);
		for (int i = 1; i <= max; i++)
		{
			ClientResource r = createResource(parent, random, depth, i);
			createNResourcesUnder(r, random, depth + 1);
		}
	}
	
	private static Headers getDefaultHeaders()
	{
		Headers headers = new Headers();
		headers.setLinkWriteStyle(LinkWriteStyle.SIMPLE);
		
		Map<String, Double> acceptedTypes = new HashMap<>();
		acceptedTypes.put(ContentType.XML.toString(), 1.0);
		acceptedTypes.put(ContentType.JSON.toString(), 0.5);
		AcceptHeader acceptedContentTypes = new AcceptHeader(Headers.ACCEPT, acceptedTypes);
		headers.setAcceptHeader(acceptedContentTypes);
		
		Map<String, Double> acceptedCharsets = new HashMap<>();
		acceptedCharsets.put(StandardCharsets.UTF_16.name(), 0.9);
		acceptedCharsets.put(StandardCharsets.UTF_8.name(), 1.0);
		headers.setAcceptHeader(new AcceptHeader(Headers.ACCEPT_CHARSET, acceptedCharsets));
		
		return headers;
	}
	
	
	// SUBCLASSES	---------------------
	
	private class ClientResource extends TreeNode<Map<String, String>>
	{
		// ATTRIBUTES	-----------------
		
		private Path path;
		
		
		// CONSTRUCTOR	-----------------
		
		public ClientResource(String name, Map<String, String> content, 
				ClientResource parent)
		{
			super(content, parent);
			
			this.path = new Path(name, parent.getPath(), false);
			getContent().put("name", name);
			
			makePost();
		}
		
		public ClientResource()
		{
			super(new HashMap<>(), null);
			
			this.path = new Path("root", null, false);
		}
		
		
		// IMPLEMENTED METHODS	---------
		
		@Override
		public ClientResource getParent()
		{
			return (ClientResource) super.getParent();
		}
		
		public List<ClientResource> getClientResourceChildren()
		{
			List<ClientResource> children = new ArrayList<>();
			for (TreeNode<Map<String, String>> childNode : getChildren())
			{
				children.add((ClientResource) childNode);
			}
			
			return children;
		}
		
		
		// ACCESSORS	-----------------
		
		public Path getPath()
		{
			return this.path;
		}
		
		
		// OTHER METHODS	-------------
		
		public void get(boolean includeChildren)
		{
			Request request = new Request(Method.GET, parseGetPath(includeChildren), 
					null, getDefaultHeaders());
			handleRequest(request);
		}
		
		public String parseGetPath(boolean includeChildren)
		{
			if (!includeChildren)
				return getPath().toString();
			else
				return getPath().getLeadingPath() + getRemainginGetPath();
		}
		
		private String getRemainginGetPath()
		{
			StringBuilder s = new StringBuilder(getPath().getContent());
			if (getChildAmount() != 0)
			{
				s.append(Path.INCLUSION);
				s.append(Path.DS);
				boolean isFirst = true;
				for (ClientResource child : getClientResourceChildren())
				{
					if (!isFirst)
						s.append(Path.INCLUSION);
					else
						isFirst = false;
					
					boolean containsMore = child.size() > 1;
					if (containsMore)
						s.append("(");
					s.append(child.getRemainginGetPath());
					if (containsMore)
						s.append(")");
				}
			}
			
			return s.toString();
		}
		
		public void put(String propertyName, String newValue)
		{
			Parameters parameters = new Parameters();
			parameters.addParameter(propertyName, newValue);
			
			Request request = new Request(Method.PUT, getPath().toString(), parameters, 
					getDefaultHeaders());
			Response response = handleRequest(request);
			if (response.getStatus().getCategory() == StatusCategory.OK)
				getContent().put(propertyName, newValue);
		}
		
		private void makePost()
		{
			Parameters parameters = new Parameters();
			for(String propertyName : getContent().keySet())
			{
				parameters.addParameter(propertyName, getContent().get(propertyName));
			}
			
			Request request = new Request(Method.POST, getPath().getParent().toString(), 
					parameters, getDefaultHeaders());
			Response response = handleRequest(request);
			if (response.getStatus().getCategory() != StatusCategory.OK)
				System.err.println("Post failed");
			else
			{
				String location = response.getHeaders().getHeaderValue(Headers.LOCATION);
				if (location == null || !location.equals(getPath().toString()))
					System.err.println("Invalid location path!");
			}
		}
	}
}
